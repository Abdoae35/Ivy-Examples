name: Build All Projects

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch: # Allow manual triggering
  schedule:
    # Check for new Ivy versions daily at 6 AM UTC
    - cron: '0 6 * * *'

env:
  DOTNET_VERSION: '9.0.x'
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true

jobs:
  check-ivy-version:
    name: Check Ivy Version
    runs-on: ubuntu-latest
    outputs:
      should-build: ${{ steps.version-check.outputs.should-build }}
      current-version: ${{ steps.version-check.outputs.current-version }}
      latest-version: ${{ steps.version-check.outputs.latest-version }}
      version-changed: ${{ steps.version-check.outputs.version-changed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Check Ivy version
        id: version-check
        run: |
          # Get the latest Ivy version from NuGet
          echo "üîç Checking latest Ivy version on NuGet..."
          latest_version=$(curl -s "https://api.nuget.org/v3-flatcontainer/ivy/index.json" | jq -r '.versions | last')
          echo "Latest Ivy version: $latest_version"
          
          # Find current Ivy version in project files
          current_version=""
          ivy_references=$(find . -name "*.csproj" -exec grep -l "Ivy" {} \; | head -1)
          
          if [ -n "$ivy_references" ]; then
            # Extract version from first project that references Ivy
            current_version=$(grep -o 'Ivy.*Version="[^"]*"' "$ivy_references" | head -1 | sed 's/.*Version="\([^"]*\)".*/\1/')
            
            # Handle wildcard versions like "1.*"
            if [[ "$current_version" == *"*"* ]]; then
              # For wildcard versions, we'll always build to check compatibility
              echo "Current version uses wildcard: $current_version"
              echo "Will build to ensure compatibility with latest version"
              should_build="true"
              version_changed="true"
            else
              echo "Current Ivy version: $current_version"
              
              # Compare versions
              if [ "$current_version" != "$latest_version" ]; then
                echo "üÜï New Ivy version available!"
                should_build="true"
                version_changed="true"
              else
                echo "‚úÖ Already using latest Ivy version"
                should_build="false"
                version_changed="false"
              fi
            fi
          else
            echo "‚ö†Ô∏è No Ivy references found in projects"
            current_version="none"
            should_build="false"
            version_changed="false"
          fi
          
          # For scheduled runs, always build if it's a version check
          if [ "${{ github.event_name }}" == "schedule" ]; then
            should_build="true"
            echo "üìÖ Scheduled run - will build to verify compatibility"
          fi
          
          # For push/PR events, always build regardless of version
          if [ "${{ github.event_name }}" == "push" ] || [ "${{ github.event_name }}" == "pull_request" ] || [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            should_build="true"
            echo "üîÑ Code change detected - will build"
          fi
          
          echo "should-build=$should_build" >> $GITHUB_OUTPUT
          echo "current-version=$current_version" >> $GITHUB_OUTPUT
          echo "latest-version=$latest_version" >> $GITHUB_OUTPUT
          echo "version-changed=$version_changed" >> $GITHUB_OUTPUT

  discover-projects:
    name: Discover Projects
    runs-on: ubuntu-latest
    needs: check-ivy-version
    if: needs.check-ivy-version.outputs.should-build == 'true'
    outputs:
      projects: ${{ steps.find-projects.outputs.projects }}
      project-count: ${{ steps.find-projects.outputs.project-count }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Find all .NET projects
        id: find-projects
        run: |
          # Find all .csproj files, excluding those in bin/obj directories
          projects=$(find . -name "*.csproj" -not -path "*/bin/*" -not -path "*/obj/*" | sort)
          
          # Convert to JSON array for matrix strategy
          project_array="["
          first=true
          while IFS= read -r project; do
            if [ "$first" = true ]; then
              first=false
            else
              project_array="$project_array,"
            fi
            
            # Get project directory name for display
            dir_name=$(dirname "$project" | xargs basename)
            project_array="$project_array{\"path\":\"$project\",\"name\":\"$dir_name\"}"
          done <<< "$projects"
          project_array="$project_array]"
          
          # Count projects
          project_count=$(echo "$projects" | wc -l)
          
          echo "Found $project_count projects:"
          echo "$projects"
          
          echo "projects=$project_array" >> $GITHUB_OUTPUT
          echo "project-count=$project_count" >> $GITHUB_OUTPUT

  build-projects:
    name: Build
    runs-on: ubuntu-latest
    needs: [check-ivy-version, discover-projects]
    if: needs.check-ivy-version.outputs.should-build == 'true' && needs.discover-projects.outputs.project-count > 0
    strategy:
      fail-fast: false # Continue building other projects even if one fails
      matrix:
        project: ${{ fromJson(needs.discover-projects.outputs.projects) }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Display .NET info
        run: dotnet --info

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restore dependencies
        run: dotnet restore "${{ matrix.project.path }}"

      - name: Build project
        run: |
          echo "üî® Building: ${{ matrix.project.name }}"
          dotnet build "${{ matrix.project.path }}" \
            --configuration Release \
            --no-restore \
            --verbosity normal

      - name: Upload build artifacts (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ matrix.project.name }}
          path: |
            **/bin/**/*.log
            **/obj/**/*.log
          retention-days: 7

  build-summary:
    name: Build Summary
    runs-on: ubuntu-latest
    needs: [check-ivy-version, discover-projects, build-projects]
    if: always() && needs.check-ivy-version.outputs.should-build == 'true' # Run even if some builds failed
    
    steps:
      - name: Generate build summary
        run: |
          echo "# üöÄ Ivy-Examples Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add Ivy version information
          echo "## üì¶ Ivy Version Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Current Version:** ${{ needs.check-ivy-version.outputs.current-version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Latest Version:** ${{ needs.check-ivy-version.outputs.latest-version }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.check-ivy-version.outputs.version-changed }}" == "true" ]; then
            echo "- **Status:** üÜï New version available!" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Status:** ‚úÖ Up to date" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Total Projects:** ${{ needs.discover-projects.outputs.project-count }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check build results
          if [ "${{ needs.build-projects.result }}" == "success" ]; then
            echo "## ‚úÖ All builds successful! üéâ" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All ${{ needs.discover-projects.outputs.project-count }} projects built successfully." >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.build-projects.result }}" == "failure" ]; then
            echo "## ‚ùå Some builds failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "One or more projects failed to build. Check the individual job logs for details." >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚ö†Ô∏è Build status: ${{ needs.build-projects.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Build Matrix Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check individual job results in the workflow run above." >> $GITHUB_STEP_SUMMARY

      - name: Set workflow status
        run: |
          if [ "${{ needs.build-projects.result }}" != "success" ]; then
            echo "‚ùå Build workflow failed"
            exit 1
          else
            echo "‚úÖ Build workflow succeeded"
          fi

  # Optional: Create a simple build status badge
  create-badge:
    name: Update Build Badge
    runs-on: ubuntu-latest
    needs: [check-ivy-version, build-summary]
    if: github.ref == 'refs/heads/main' && always() && needs.check-ivy-version.outputs.should-build == 'true'
    
    steps:
      - name: Create build status badge
        run: |
          if [ "${{ needs.build-summary.result }}" == "success" ]; then
            badge_color="brightgreen"
            badge_message="passing"
          else
            badge_color="red"
            badge_message="failing"
          fi
          
          echo "Build status: $badge_message ($badge_color)"
          # You can extend this to actually update a badge service like shields.io
